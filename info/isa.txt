Key:
val = Immediate Value
reg = Register ID
label = Label name
name = Variable Name

16-Bit Registers:
0 - A
1 - B
2 - C
3 - D
4 - F #Flags
5 - PC #Program Counter

Flags:
Zero
Negative
Overflow

Prefixes:
! = Immediate Value
@ = Register ID
0b = Binary
0x = Hexadecimal
. = Label
$ = Variable

======================================================================================================================

Instructions:
0 -> NOP #No operation
1 -> LDA <val> #Load <val> into register A
2 -> LDB <val> #Load <val> into register B
3 -> LDC <val> #Load <val> into register C
4 -> LDD <val> #Load <val> into register D
5 -> SWP <reg1> <reg2> #Swaps the value in <reg1> and <reg2>
6 -> MOV <reg1> <reg2> #Move the value in <reg1> to <reg2> (overwrites the contents of <reg2>)
7 -> STA <reg> #Store register A's contents at the RAM address stored in <reg>
8 -> STB <reg> #Store register B's contents at the RAM address stored in <reg>
9 -> STC <reg> #Store register C's contents at the RAM address stored in <reg>
10 -> STD <reg> #Store register D's contents at the RAM address stored in <reg>
11 -> LRA <reg> #Loads the contents of the RAM address stored in <reg> into register A
12 -> LRB <reg> #Loads the contents of the RAM address stored in <reg> into register B
13 -> LRC <reg> #Loads the contents of the RAM address stored in <reg> into register C
14 -> LRD <reg> #Loads the contents of the RAM address stored in <reg> into register D
15 -> PSH <reg> #Pushes the contents of <reg> onto the stack
16 -> POP <reg> #Pops the value at the stack pointer into <reg>
17 -> ADD <reg1> <reg2> #Adds <reg1> to <reg2>, and stores the result in <reg1>
18 -> SUB <reg1> <reg2> #Subtracts <reg1> from <reg2>, and stores the result in <reg1>
19 -> MUL <reg1> <reg2> #Multiplies <reg1> by <reg2>, and stores the result in <reg1>
20 -> DIV <reg1> <reg2> #Divides <reg1> by <reg2>, and stores the result in <reg1>
21 -> AND <reg1> <reg2> #Puts <reg1> and <reg2> through a bitwise AND gate, and stores the result in <reg1>
22 -> OR <reg1> <reg2> #Puts <reg1> and <reg2> through a bitwise OR gate, and stores the result in <reg1>
23 -> NOR <reg1> <reg2> #Puts <reg1> and <reg2> through a bitwise NOR gate, and stores the result in <reg1>
24 -> XOR <reg1> <reg2> #Puts <reg1> and <reg2> through a bitwise XOR gate, and stores the result in <reg1>
25 -> NOT <reg> #Puts <reg> through a bitwise NOT gate, and stores the result in <reg>
26 -> INC <reg> #Increments <reg> by 1
27 -> DEC <reg> #Decrements <reg> by 1
28 -> JMP <label> #Jumps to <label> unconditionally
29 -> CMP <reg1> <reg2> #Subtracts the contents of <reg2> from <reg1>; updates flags accordingly
30 -> JZ <label> #Jump to <label> if the Zero flag is 1
31 -> JNZ <label> #Jump to <label> if the Zero flag is 0
32 -> JN <label> #Jump to <label> if the Negative flag is 1
33 -> JNN <label> #Jump to <label> if the Negative flag is 0
34 -> JO <label> #Jump to <label> if the Overflow flag is 1
35 -> JNO <label> #Jump to <label> if the Overflow flag is 0
36 -> OUT <reg> #Prints the value in <reg> to the terminal
37 -> HLT <code> #Stops the program with exit code <code> (if <code> is ommited, then "0" is used)

======================================================================================================================

RAM Sections:
Main - 65280 slots
Stack - 256 slots

======================================================================================================================

Label Declaration:
.label <name>
    ...

======================================================================================================================

Directives:
Integer Variable -> #def <name> <val>